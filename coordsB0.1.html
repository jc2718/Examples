<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>3D Coordinate System</title>
    <style>
      canvas {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      // Get the canvas element and its 3D context
      const canvas = document.getElementById('canvas');
      const gl = canvas.getContext('webgl');

      // Define the vertex shader code
      const vsSource = `
        attribute vec4 aVertexPosition;
        attribute vec4 aVertexColor;
        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        varying lowp vec4 vColor;

        void main() {
          gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
          vColor = aVertexColor;
        }
      `;

      // Define the fragment shader code
      const fsSource = `
        varying lowp vec4 vColor;

        void main() {
          gl_FragColor = vColor;
        }
      `;

      // Compile and link the shaders
      const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const shaderProgram = createProgram(gl, vertexShader, fragmentShader);

      // Get the locations of the vertex attributes and uniforms
      const vertexPositionAttribute = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
      const vertexColorAttribute = gl.getAttribLocation(shaderProgram, 'aVertexColor');
      const modelViewMatrixUniform = gl.getUniformLocation(shaderProgram, 'uModelViewMatrix');
      const projectionMatrixUniform = gl.getUniformLocation(shaderProgram, 'uProjectionMatrix');

      // Create a buffer for the vertex positions
      const positionBuffer = gl.createBuffer();

      // Define the x, y, and z functions
      const xFunction = (u, v) => Math.sin(u);
      const yFunction = (u, v) => v;
      const zFunction = (u, v) => Math.cos(u);

      // Define the color of the surface
      const color = [0.8, 0.8, 0.8, 1.0];

      // Define the number of divisions in the u and v directions
      const divisionsU = 40;
      const divisionsV = 40;

      // Define the range of u and v values
      const uMin = -Math.PI;
      const uMax = Math.PI;
      const vMin = -3;
      const vMax = 3;

      // Create an array to hold the vertex positions and colors
      const vertices = [];
      const colors = [];

      // Compute the vertex positions and colors
      for (let i = 0; i <= divisionsU; i++) {
        const u = uMin + (i / divisionsU) * (uMax - uMin);
        for (let j = 0; j <= divisionsV; j++) {
          const v = vMin + (j / divisionsV) * (vMax - vMin);
          const x = xFunction(u, v);
          const y = yFunction(u, v);
          const z = zFunction(u, v);
         
