<!DOCTYPE html>
<html>
  <head>
    <title>Lorenz System Animation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.101.1/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/dat.gui"></script>

    <style>
      body {
        margin: 0;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
  
  
    <script>
      // Create the scene, camera, and renderer
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 500);
      camera.position.set(-29, 7, 50);

      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
       
      const axesHelper = new THREE.AxesHelper(5);
      scene.add(axesHelper);
      
      const gui = new dat.GUI();
      const params = { rho: 28, };
      gui.add(params, "rho", 1, 50).step(1);  

      // Add a cube to the scene
      //const geometry = new THREE.BoxGeometry(1, 1, 1);
      //const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      //const cube = new THREE.Mesh(geometry, material);
      //scene.add(cube);

      // Set up mouse controls to rotate the camera
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.25;
      controls.screenSpacePanning = false;
      controls.minDistance = 1;
      controls.maxDistance = 100;
      controls.maxPolarAngle = Math.PI / 2;

      // Set the initial camera position
      camera.position.z = 5; 

    // Assign functions, init variables
    const initial = 40;    
    let x = initial;  
    let y = initial;  
    let z = initial; 
    
    sigma = 10;
    let rho = 28;
    beta = 8/3;
    dt = 0.001;



    /*const rhoSlider = document.getElementById("rho-slider");
    const rhoValue = document.getElementById("rho-value");
    rhoSlider.addEventListener("input", (event) => {
    const newRho = event.target.value;
    rho = parseFloat(newRho);
    */

    const dxFunction = (y,x) => sigma * (y - x);
    const dyFunction = (z,y) => x * (rho - z) - y;
    const dzFunction = (x,y,z) => x * y - beta * z;

    let curvePoints = [];
    const oldCurves = [];
    const maxtail = 10000;

    // Add an animation loop  
    const animate = function () {
    
    requestAnimationFrame(animate);
    
      // update rho based on the slider value
      rho = params.rho;     
      
      x += dxFunction(y,x) * dt;
      y += dyFunction(z,y) * dt;
      z += dzFunction(x,y,z) * dt;
      curvePoints.push(new THREE.Vector3(x, y, z));
      if (curvePoints.length > maxtail){const tailpoint = curvePoints.shift();   }
  

      const curveGeometry = new THREE.BufferGeometry().setFromPoints(curvePoints);
      const curveMaterial = new THREE.LineBasicMaterial({ color: 0xB4B801 });
      const curve = new THREE.Line(curveGeometry, curveMaterial);

      scene.add(curve);
      renderer.render(scene, camera);

      // add the new curve to the array of old curves
      oldCurves.push(curve);

      // remove old curves from the scene
            if (oldCurves.length > 10) {
              const curveToRemove = oldCurves.shift();
              scene.remove(curveToRemove);
              curveToRemove.geometry.dispose();
              curveToRemove.material.dispose();
              }

        
      };
      animate();


    </script>
  </body>
</html>
